<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>node_koa</title>
</head>
<body>
  <p>命令：</p>
  <p>升级node：npm i -g n</p>
  <p>npm install把package.json里面的插件安装好</p>
  <p>npm i nodemon -g 自动运行node</p>
  <p>debugger调试，创建配置文件，复制里面的默认配置，把"program"改成对应的路径"name"改标题，"program": "${file}"为当前文件，添加配置里面选nodemon是自动重启debugger调试</p>
  <p>process.cwd()获得的是当前路径的根目录</p>
  <p>sql查询：await User.findOne({where: {email: email}})</p>
  <p>sql添加：await User.create(user)</p>
  <p>密码加密：1、导入：const bcrypt = require('bcryptjs') 2、设置加密等级：const salt = bcrypt.genSaltSync(10) const 3、生成密码：psw = bcrypt.hashSync(v.get('body.password2'), salt)</p>
  <textarea name="" id="" cols="30" rows="10">
    基础：
    const Koa = require('koa')
    const app = new Koa()
    app.use((ctx, next) => {
      console.log('holle,7yue')
      next()
    })
    app.use((ctx, next) => {
      console.log('holle.8yue')
    })
    app.listen(3000)
  </textarea>

  <textarea name="" id="" cols="30" rows="10">
    async和await：
    app.use(async (ctx, next) => {
      await next()
      const r = ctx.r
      console.log(r)
    })
    app.use(async(ctx, next) => {
      const axios = require('axios')
      const res = await axios.get('http://7yue.pro')
      ctx.r = res
      await next()
    })
  </textarea>

  <textarea name="" id="" cols="30" rows="10">
    koa-router：
    const Koa = require('koa')
    const Router = require('koa-router')
    const app = new Koa()
    const router = new Router()
    router.get('/classic/latest', (ctx, next) => {
      ctx.body = { key: 'classic' }
    })
    app.use(router.routes())
    app.listen(3000)
  </textarea>

  <textarea name="" id="" cols="30" rows="10">
    分离代码：
      子文件：
      const Router = require('koa-router')
      const router = new Router()
      router.get('/v1/classic/latest', (ctx, next) => {
        ctx.body = {
          key: 'classic' 
        }
      })
      module.exports = router
      父文件：
      const Koa = require('koa')
      const classic = require('./api/v1/classic')
      const app = new Koa()
      app.use(classic.routes())
      app.listen(3000)
  </textarea>

  <textarea name="" id="" cols="30" rows="10">
    自动化加载api：
    const Router = require('koa-router')
    const requireDirectory = require('require-directory')
    requireDirectory(module, './api', {
      visit: whenLoadModule
    })
    function whenLoadModule (obj) { // module == obj
      if (obj instanceof Router) {
        app.use(obj.routes()) // 中间件注册
      }
    }
  </textarea>

  <textarea name="" id="" cols="30" rows="10">
    将app.js代码分离：
      init.js：
      const requireDirectory = require('require-directory')
      const Router = require('koa-router')
      class InitManager{
        static initCore (app) {
          // 入口方法
          InitManager.app = app
          InitManager.initLoadRouters() 
        }
        static initLoadRouters () {
          const apiDirectory = `${ process.cwd() }/app/api`
          requireDirectory(module, apiDirectory, { 
            visit: whenLoadModule
          })
          function whenLoadModule (obj) {
            if (obj instanceof Router) {
              InitManager.app.use(obj.routes())
            }
          }
        }
      }
      module.exports = InitManager
      app.js：
      const Koa = require('koa')
      const InitManager = require('./core/init')
      const app = new Koa()
      InitManager.initCore(app)
      app.listen(3000)
  </textarea>

  <textarea name="" id="" cols="30" rows="10">
    获取前端传过来的值：
    router.post('/v1/:id/classic/latest', (ctx, next) => {
      const path = ctx.params
      const query = ctx.request.query
      const headers = ctx.request.header
      const body = ctx.request.body
      ctx.body = {
        key: 'classic' 
      }
    })
    body需要注册之后才能用：
    const parser = require('koa-bodyparser')
    app.use(parser())
  </textarea>

  <textarea name="" id="" cols="30" rows="10">
    创建一个全局处理异常以面向切面方式处理：
      module层：
      const error = new Error('为什么错误') // 因为message是Error的构造函数所以可以直接new出来
      error.errorCode = 10001
      error.status = 400
      error.requestUrl = `${ ctx.method } ${ ctx.path }`
      throw error
      处理异常文件：
      const catchError = async (ctx, next) => {
        try {
          await next()
        } catch (error) {
          if (error.errorCode) {
            ctx.body = {
              msg: error.message,
              error_code: error.errorCode,
              request: error.requestUrl,
            }
            ctx.status = error.status
          }
        }
      }
      module.exports = catchError
      再把文件注册一下：
      const catchError = require('./middlewares/exception')
      app.use(catchError)
  </textarea>
  <textarea name="" id="" cols="30" rows="10">
    创建一个异常处理的类：
    class HttpException extends Error {
      constructor (msg='服务器异常', errorCode=10000, code=400) {
        super()
        this.errorCode = errorCode
        this.code = code
        this.msg = msg
      }
    }
    其它页面实例化就可以了：
    const error = new ParameterException('发现错误', 10001, 400)
    throw error
  </textarea>
  <textarea name="" id="" cols="30" rows="10">
    LinValidator的使用：
    const { LinValidator, Rule } = require('../../core/lin-validator')
    class PositiveIntegerValidator extends LinValidator {
      constructor () {
        super()
        this.id = [
          new Rule('isInt', '需要是正整数', { min: 1 }),
        ]
      }
    }
    module.exports = { PositiveIntegerValidator }
    在其它页面实例化：
    const v = new PositiveIntegerValidator().validate(ctx)
    获取前端传给后端的值：
    const id = v.get('path.id')
  </textarea>
  <textarea name="" id="" cols="30" rows="10">
    配置生产环境和开发环境：
    module.exports = {
      // prod
      // dev
      environment: 'dev'
    }
    在入口文件定义全局变量：
    static loadConfig (path = '') {
      const configPath = path || process.cwd() + '/config/config'
      const config = require(configPath)
      global.config = config
    }
    在全局监控异常处加入判断：
    if (global.config.environment === 'dev') {
      throw error
    }
  </textarea>
  <textarea name="" id="" cols="30" rows="10">
    连接数据库：
    database: {
      dbName: '7yue',
      host: 'localhost',
      port: 3306,
      user: 'root',
      password: '123',
    }
    const Sequelize = require('sequelize')
    const { 
      dbName,
      host,
      post,
      user,
      password
    } = require('../config/config').database
    const sequelize = new Sequelize(dbName, user, password, {
      dialect: 'mysql', // 连接什么数据库就改什么名字，驱动需要更换
      host, 
      post,
      logging: true, // 是否显示日志文件
      timezone: '+08:00', // Sequelize的时间和北京时间相差8小时
      define: {
      }
    })
    sequelize.sync()
    module.exports = {
      sequelize
    }
  </textarea>
  <textarea name="" id="" cols="30" rows="10">
    创建数据库的表：
    const { sequelize } = require('../../core/db')
    const {
      Sequelize,
      Model
    } = require('sequelize')
    class User extends Model {
    }
    User.init({
      id: {
        type: Sequelize.INTEGER,
        primaryKey: true, // 主键
        autoIncrement: true, // 自动增长
      },
      nickname: Sequelize.STRING,
      email: Sequelize.STRING,
      password: Sequelize.STRING,
      openid: {
        type: Sequelize.STRING(64),
        unique: true, // 唯一的
      }
    }, { sequelize })
    然后在app.js引入：
    require('./app/models/user')
  </textarea>
  <textarea name="" id="" cols="30" rows="10">
    axios的使用：
    const util = require('util')
    const axios = require('axios')
    const url = util.format(global.config.wx.loginUrl, global.config.wx.appId, global.config.wx.appSecret, code)
    const result = await axios.get(url)
  </textarea>
</body>
</html>